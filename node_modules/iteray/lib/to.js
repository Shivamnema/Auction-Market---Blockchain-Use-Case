'use strict'

const AsyncQueue = require('./AsyncQueue')
const stream = require('stream')
const {equals, is, to} = require('@nodeguy/type')

// Array

to.method([equals(Array), is(Object)],
  (type, object) => {
    const array = []

    for (let key in object) {
      array.push([key, object[key]])
    }

    return array
  }
)

to.method([equals(Array), is('Iterable')],
  (type, iterable) =>
    Array.from(iterable)
)

to.method([equals(Array), is('AsyncIterable')],
  (type, asyncIterable) => {
    const asyncIterator = asyncIterable[Symbol.asyncIterator]()
    const array = []

    return new Promise((resolve) => {
      const next = () => {
        asyncIterator.next().then((result) => {
          if (result.done) {
            resolve(array)
          } else {
            array.push(result.value)
            setImmediate(next)
          }
        })
      }

      next()
    })
  }
)

to.method([equals(Array), is(stream.Readable)],
  (type, readableStream) => {
    const array = []

    return new Promise((resolve, reject) => {
      readableStream.on('data', (chunk) => {
        array.push(chunk)
      })

      readableStream.once('end', () => {
        resolve(array)
      })

      readableStream.once('error', reject)
    })
  }
)

// Object

to.method([equals(Object), is(Array)],
  (type, array) => {
    const object = {}

    for (const [key, value] of array) {
      object[key] = value
    }

    return object
  }
)

// Iterator

to.method(['Iterator', is('AsyncIterable')],
  (type, asyncIterable) =>
    asyncIterable[Symbol.asyncIterator]()
)

to.method(['Iterator', is('Iterable')],
  (type, iterable) =>
    iterable[Symbol.iterator]()
)

// Iterable

to.method(['Iterable', is(Function)],
  (type, next) => ({
    [Symbol.iterator]: () => ({
      next
    })
  })
)

to.method(['Iterable', is(Array)],
  function * (type, array) {
    for (let element of array) {
      yield element
    }
  }
)

// AsyncIterable

to.method(['AsyncIterable', is(stream.Readable)],
  (type, stream) => {
    const asyncQueue = AsyncQueue()

    stream.on('data', (value) => {
      asyncQueue.push(Promise.resolve({done: false, value}))
    })

    stream.on('end', () =>
      asyncQueue.push(Promise.resolve({done: true}))
    )

    stream.on('error', (error) =>
      asyncQueue.push(Promise.reject(error))
    )

    return asyncQueue
  }
)

to.method(['AsyncIterable', is('Iterable')],
  (type, iterable) => {
    const iterator = to('Iterator', iterable)

    return {
      [Symbol.asyncIterator]: () => ({
        next: () =>
          Promise.resolve(iterator.next())
      })
    }
  }
)

to.method(['AsyncIterable', is(Array)],
  (type, array) => {
    const asyncQueue = AsyncQueue()

    array.forEach((value) =>
      asyncQueue.push(Promise.resolve({done: false, value})))

    asyncQueue.push(Promise.resolve({done: true}))
    return asyncQueue
  }
)

// Node.js stream

const ReadableStream = (read) => {
  const readable = new stream.Readable({objectMode: true})
  readable._read = () => read(readable.push.bind(readable))
  return readable
}

to.method([equals(stream.Readable), is('Iterable')],
  (type, iterable) => {
    const input = to('Iterator', iterable)

    return ReadableStream((push) => {
      const result = input.next()
      push(result.done ? null : result.value)
    })
  }
)

to.method([equals(stream.Readable), is('AsyncIterable')],
  (type, asyncIterable) => {
    const input = to('Iterator', asyncIterable)

    return ReadableStream((push) => {
      input.next().then((result) => {
        push(result.done ? null : result.value)
      })
    })
  }
)

to.method([equals(stream.Readable), is(Array)],
  (type, array) => {
    const copy = array.slice()

    return ReadableStream((push) => {
      push(copy.length === 0 ? null : copy.shift())
    })
  }
)

module.exports = to
