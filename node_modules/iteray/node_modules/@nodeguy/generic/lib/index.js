'use strict'

const _ = () => true

const matchObjects = (pattern, value) => {
  const patternKeys = Object.keys(pattern)
  const valueKeys = Object.keys(value)

  return patternKeys.length === valueKeys.length
    ? patternKeys.every((key) => match(pattern[key], value[key]))
    : false
}

const match = (pattern, value) =>
  // If the pattern is a function then use it as a predicate.
  ((typeof pattern === 'function')
    ? pattern(value) === true
    // If the pattern is a Regular Expression then test against it.
    : pattern instanceof RegExp
      // Prevent automatic conversion of value to string.
      ? (typeof value === 'string') && pattern.test(value)
      // Check for equality.
      : Object.is(pattern, value) ||
        // If both are Objects then check their properties.
        ((pattern instanceof Object) && (value instanceof Object) &&
          matchObjects(pattern, value)
        )
  )

const errorMessage = (name, argumentsLength) => {
  const argumentsCount = argumentsLength === 1
    ? 'single argument'
    : `${argumentsLength} arguments`

  const nameString = name
    ? " '" + name + "'"
    : ''

  return `No method matches ${argumentsCount} in call to generic function` +
    `${nameString}.`
}

const create = (options = {}) => {
  const methods = []

  // TO DO: Rewrite curry according to this:
  // http://stackoverflow.com/questions/27996544/how-to-correctly-curry-a-function-in-javascript
  const dispatch = function () {
    // Begin by assuming a match isn't possible.
    let matchPossible = false

    // Try each method, starting with the last one defined.
    for (let index = methods.length - 1; index >= 0; index--) {
      const method = methods[index]

      if (match(method.pattern, arguments)) {
        const implementation = method.implementation

        return typeof implementation === 'function'
          ? implementation.apply(this, arguments)
          : implementation
      } else if (!Array.isArray(method.pattern) ||
        (method.pattern.length > arguments.length)) {
        matchPossible = true
      }
    }

    // If we're currying then bind the current set of arguments and try again.
    if (matchPossible && options.curry) {
      return dispatch.bind(this, ...arguments)
    } else {
      throw new ReferenceError(errorMessage(options.name, arguments.length))
    }
  }

  dispatch.method = (pattern, implementation) => {
    methods.push({pattern, implementation})
  }

  return dispatch
}

module.exports = {
  _,
  create,
  match
}
