'use strict'

const className = require('./className')
const equals = require('./equals')
const generic = require('@nodeguy/generic')
const _ = generic._
const has = require('./has')

const is = generic.create({name: 'is', curry: true})

// default
is.method([_, _],
  (Type, value) => {
    const name = className(value)

    return (value instanceof Type) ||
      // We can check objects from other contexts if they have non-'Object'
      // class names.
      ((name !== 'Object') && (name === className(new Type())))
  }
)

// AsyncIterable
is.method(['AsyncIterable', _], false)

is.method(['AsyncIterable', is(Object)],
  (type, value) =>
    is(Function, value[Symbol.asyncIterator]) &&
      is('Iterator', value[Symbol.asyncIterator]())
)

// Iterable
is.method(['Iterable', _], false)

is.method(['Iterable', is(Object)],
  (type, value) =>
    is(Function, value[Symbol.iterator]) &&
      is('Iterator', value[Symbol.iterator]())
)

// Iterator
is.method(['Iterator', _], false)

is.method(['Iterator', is(Object)],
  (type, value) =>
    is(Function, value.next)
)

// Errors
is.method([_, value => value instanceof Error],
  (type, value) =>
    value.name === type.name
)

// Object
is.method([equals(Object), _],
  (type, value) =>
    typeof value === 'object'
)

// arguments
is.method(['arguments', _],
  (type, value) =>
    has(['callee', 'length', Symbol.iterator], value)
)

// Array
// Without this test, is(Array) returns true for Array Iterators.
is.method([equals(Array), _], false)
is.method([equals(Array), Array.isArray], true)

// Symbol
is.method([equals(Symbol), _],
  (type, value) =>
    typeof value === 'symbol'
)

// Null
is.method([null, _], false)
is.method([null, null], true)

// Undefined
is.method([undefined, _], false)
is.method([undefined, undefined], true)

module.exports = is
