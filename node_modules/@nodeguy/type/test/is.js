'use strict'

const assert = require('assert')
const type = require('../lib')
const className = type.className
const is = type.is
const vm = require('vm')

it('Undefined', function () {
  assert(is(undefined, undefined))
})

it('Null', function () {
  assert(is(null, null))
})

describe('literals', function () {
  it('Boolean', function () {
    assert(is(Boolean, false))
  })

  it('Number', function () {
    assert(is(Number, 42))
  })

  it('String', function () {
    assert(is(String, 'theory'))
  })
})

describe('Symbol', function () {
  it('same context', function () {
    assert(is(Symbol, Symbol()))
  })

  it('different context', function () {
    assert(is(Symbol, vm.runInNewContext('Symbol()')))
  })
})

const constructors = [
  Array,
  ArrayBuffer,
  Boolean,
  Date,
  Error,
  EvalError,
  Float32Array,
  Float64Array,
  Function,
  Int8Array,
  Int16Array,
  Int32Array,
  Map,
  Number,
  Object,
  RangeError,
  ReferenceError,
  RegExp,
  Set,
  String,
  SyntaxError,
  TypeError,
  Uint8Array,
  Uint8ClampedArray,
  Uint16Array,
  Uint32Array,
  URIError,
  WeakMap,
  WeakSet
]

constructors.forEach((constructor) => {
  const name = className(new constructor())

  describe(name, function () {
    it('same context', function () {
      assert(is(constructor, new constructor()))
    })

    it('different context', function () {
      assert(is(constructor, vm.runInNewContext(`new ${name}()`)))
    })
  })
})

it('arguments', function () {
  function foobar () {
    assert(is('arguments', arguments))
  }

  foobar()

  assert(!is('arguments', null))
})

it('distinguishes between different types of Errors', function () {
  assert(!is(EvalError, new RangeError()))
})

it('Iterator', function () {
  assert(is('Iterator', {next: () => {}}))
})

it('Array Iterator', function () {
  const entries = [1, 2, 3].entries()
  assert(is('Iterator', entries))
  assert(!is(Array, entries))
})

it('Iterable', function () {
  assert(is('Iterable', [1, 2, 3]))
})

it('AsyncIterable', function () {
  const asyncIterable = {
    [Symbol.asyncIterator]: () => ({
      next: () => Promise.resolve({done: true})
    })
  }

  assert(is('AsyncIterable', asyncIterable))
})

it('inheritance', function () {
  class Super {}
  class Sub extends Super {}

  assert(is(Super, new Sub()))
  assert(!is(Sub, new Super()))
})
