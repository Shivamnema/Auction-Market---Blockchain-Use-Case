'use strict'

const matchObjects = (pattern, value) => {
  const patternKeys = Object.keys(pattern)

  if (Object.keys(value).length >= patternKeys.length) {
    return Object.assign({}, value, ...patternKeys.map((key) =>
      ({[key]: match(pattern[key], value[key])})
    ))
  } else {
    throw new Error()
  }
}

const match = (pattern, value) => {
  // If the pattern is a function then use it as a predicate.
  if (typeof pattern === 'function') {
    if (pattern(value) === true) {
      return value
    }
  // If the pattern is a Regular Expression then test against it.
  } else if (pattern instanceof RegExp) {
    if (typeof value === 'string') {
      const result = value.match(pattern)

      if (result !== null) {
        return result
      }
    }
  // Check for equality.
  } else if (Object.is(pattern, value)) {
    return value
  // If both are Arrays then check their items.
  } else if (Array.isArray(pattern) && Array.isArray(value)) {
    if (value.length >= pattern.length) {
      return pattern
        .map((item, index) => match(item, value[index]))
        .concat(value.slice(pattern.length))
    }
  // If both are Objects then check their properties.
  } else if ((pattern instanceof Object) && (value instanceof Object)) {
    return matchObjects(pattern, value)
  }

  throw new Error()
}

const errorMessage = (name, argumentsLength) => {
  const argumentsCount = argumentsLength === 1
    ? 'single argument'
    : `${argumentsLength} arguments`

  const nameString = name
    ? " '" + name + "'"
    : ''

  return `No method matches ${argumentsCount} in call to generic function` +
    `${nameString}.`
}

const func = (options = {}) => {
  const methods = []

  // TO DO: Rewrite curry according to this:
  // http://stackoverflow.com/questions/27996544/how-to-correctly-curry-a-function-in-javascript
  const dispatch = (...args) => {
    // Begin by assuming a match isn't possible.
    let matchPossible = false

    // Try each method, starting with the last one defined.
    for (let index = methods.length - 1; index >= 0; index--) {
      const {pattern, implementation} = methods[index]
      let matchedArgs

      try {
        matchedArgs = match(pattern, args)
      } catch (exception) {
      }

      if (matchedArgs) {
        return typeof implementation === 'function'
          ? implementation(...matchedArgs)
          : implementation
      } else if (!Array.isArray(pattern) ||
        (pattern.length > args.length)) {
        matchPossible = true
      }
    }

    // If we're currying then bind the current set of arguments and try again.
    if (matchPossible && options.curry) {
      return dispatch.bind(this, ...args)
    } else {
      throw new ReferenceError(errorMessage(options.name, args.length))
    }
  }

  dispatch.method = (pattern, implementation) => {
    methods.push({pattern, implementation})
  }

  return dispatch
}

module.exports = {
  _: () => true,
  create: func,
  function: func,
  match
}
