// Parse the JavaScript language specification for our purposes.

'use strict'

const generic = require('@nodeguy/generic')
const _ = generic._
const parse5 = require('parse5')

const htmlStreamToDocument = (stream) =>
  new Promise((resolve) => {
    const parser = new parse5.ParserStream()

    parser.once('finish', () => {
      resolve(parser.document)
    })

    stream.pipe(parser)
  })

const nodeToMethodSpecifications = generic.function()

nodeToMethodSpecifications.method([{childNodes: _}],
  ({childNodes}) =>
    [].concat(...childNodes.map(nodeToMethodSpecifications))
)

nodeToMethodSpecifications.method([{childNodes: undefined}], [])

const parseArgs = (args) =>
  args.match(/(\w+)/g) || []

nodeToMethodSpecifications.method([{
  tagName: 'h1',
  childNodes: [
    {childNodes: [_]},
    {value: / (.+)\.prototype\.(\w+) ?\((.+)\)/}
  ]
}],
  ({childNodes: [
    {childNodes: [{attrs: [{value: fragment}]}]},
    {value: [, object, name, args]}
  ]}) => [{fragment, object, name, args: parseArgs(args)}]
)

const convertArgs = (specification) => {
  const map = new Map([
    ['arguments', 'args'],
    ['date', 'day']
  ])

  const args = specification.args.map((arg) =>
    map.has(arg) ? map.get(arg) : arg
  )

  return Object.assign({}, specification, {
    args: args.slice(-1)[0] === 'thisArg'
      ? args.slice(0, -1)
      : args
  })
}

const methods = generic.function()

methods.method(_,
  (specification) => specification
)

// http://www.ecma-international.org/ecma-262/6.0/#sec-typedarray-objects
const arrayTypes = [
  'Int8Array',
  'Uint8Array',
  'Uint8ClampedArray',
  'Int16Array',
  'Uint16Array',
  'Int32Array',
  'Uint32Array',
  'Float32Array',
  'Float64Array'
]

methods.method([{object: '%TypedArray%'}],
  (specification) =>
    arrayTypes.map((object) => Object.assign({}, specification, {object}))
)

methods.method([{
  args: [(arg) => ['overloaded', 'typedArray'].includes(arg), 'offset'],
  object: '%TypedArray%',
  name: 'set'
}], [])

methods.method([{object: 'Generator'}], [])

const mapGetWithDefault = (key, defaultValue, map) => {
  if (!map.has(key)) {
    map.set(key, defaultValue)
  }

  return map.get(key)
}

module.exports = (specification) =>
  htmlStreamToDocument(specification).then((document) => {
    const functions = new Map()

    nodeToMethodSpecifications(document)
      .map(convertArgs)
      .reduce((previous, current) => previous.concat(methods(current)), [])
      .forEach(({name, args, fragment, object}) => {
        const func = mapGetWithDefault(name, new Map(), functions)
        const group = mapGetWithDefault(JSON.stringify(args), [], func)
        group.push({fragment, object})
      })

    return functions
  })
