// Generates functions and tests boilerplate by reading the JavaScript language
// specification.  This is here for reference only; you don't want to run it
// again because it will overwrite customizations.

'use strict'

const fs = require('fs')
const parseSpecification = require('./parseSpecification')
const path = require('path')

const documentationPath = (name) =>
  path.join(__dirname, '../doc', name)

const href = (fragment) =>
  'https://www.ecma-international.org/ecma-262/6.0/' + fragment

const argumentsToString = (args) =>
  `(${args.join(', ')})`

const objectToArgument = (name) =>
  name === 'Function'
    ? 'func'
    : name[0].toLowerCase() + name.slice(1)

const objectsArgument = (methods) =>
  methods.map(({fragment, object}) =>
    `[${objectToArgument(object)}](${href(fragment)})`
  ).sort().join(' | ')

const functionDocumentation = (name, args, methods) =>
  `* ${name} ${argumentsToString(args.concat(objectsArgument(methods)))}`

const groupDocumentation = ([name, group]) =>
  [...group.entries()]
    .sort()
    .map(([args, methods]) =>
      functionDocumentation(name, JSON.parse(args), methods)
    )

const documentation = (functions) =>
  [...functions.entries()]
    .sort()
    .reduce(
      (previous, current) => previous.concat(groupDocumentation(current)),
      []
    )
    .join('\n')

const specificationName =
  'ECMAScript 2015 Language Specification â€“ ECMA-262 6th Edition.html'

const methodTest = (name) =>
  ({object}) =>
`  // This is an automatically generated stub.
  it('${object}', function () {
    assert('${name}' in G)
  })`

const functionTest = (name, groups) => {
  const itDefinitions = [...groups.entries()]
    .reduce((previous, [, group]) =>
      previous.concat(group.map(methodTest(name))),
    [])
    .join('\n\n')

  return `'use strict'

const assert = require('assert')
const G = require('../../lib')

describe('add', function () {
${itDefinitions}
})
`
}

const methodImplementation = (name, args) =>
  ({fragment, object}) => {
    const pattern = args.map(() => '_').concat(`is(${object})`).join(', ')
    const objectArgument = objectToArgument(object)

    return `// ${href(fragment)}
${name}.method([${pattern}],
  ${argumentsToString(args.concat(objectArgument))} =>
    ${objectArgument}.${name}${argumentsToString(args)}
)`
  }

const functionLib = (name, groups) => {
  const reserved = ['catch', 'delete']
  const constantName = reserved.includes(name) ? name + 'Function' : name
  let usedUnderscore = false

  const definitions = [...groups.entries()]
    .reduce((previous, [args, group]) => {
      const parsedArgs = JSON.parse(args)

      if (parsedArgs.length > 0) {
        usedUnderscore = true
      }

      return previous.concat(group.map(methodImplementation(
        constantName,
        parsedArgs
      )))
    },
    [])
    .join('\n\n')

  return `'use strict'

const generic = require('@nodeguy/generic')
${usedUnderscore ? 'const _ = generic._\n' : ''}const is = require('@nodeguy/type').is

const ${constantName} = generic.function({name: '${name}', curry: true})

${definitions}

module.exports = ${constantName}
`
}

const writeDocumentation = (functions) => {
  fs.writeFile(documentationPath('index.md'), documentation(functions))
}

const writeImplementation = (groups, name) => {
  fs.writeFile(
    path.join(__dirname, '../test/functions', name + '.js'),
    functionTest(name, groups)
  )

  fs.writeFile(
    path.join(__dirname, '../lib/functions', name + '.js'),
    functionLib(name, groups)
  )
}

parseSpecification(
  fs.createReadStream(documentationPath(specificationName))
)
  .then((functions) => {
    writeDocumentation(functions)
    functions.forEach(writeImplementation)
  })
  .catch(console.error)
